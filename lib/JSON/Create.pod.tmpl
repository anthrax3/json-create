[%- start_year = '2015' -%]
[% MACRO see(method) BLOCK -%]
This behaviour can be altered with the method L</[% method %]>
[%- END %]
[% MACRO since(version) BLOCK -%]
This method was added in version [% version %] of the module.
[%- END %]
[% MACRO handler_undef BLOCK -%]

If your handler returns the undefined value, L</run> prints a warning,
halts further processing of the input, and returns the undefined
value.

[%- END %]
[% MACRO handler_common(handler) BLOCK -%]
=over

=item * Calling convention

The [% handler %] routine is passed a single argument and is expected
to return a single argument, which is the JSON you wish to output. It
is called in scalar context. In other words, the call looks like the
following:

     $json = &{$jc->{[% handler %]}} ($item);

To pass or return multiple values via the C<[% handler %]> callback,
use a closure. See the discussion at L</obj> for an example.

=item * Returning undef halts processing

[% handler_undef %]

=item * Delete the handler with any false value

To remove the handler, simply call the function without an argument,

    $jc->[% handler %] ();

or with a false argument:

    $jc->[% handler %] (0);

The behaviour then reverts to the default.

=item * Checking the output JSON

The JSON output by your handler may be checked for validity by
switching on validation using L</validate>.

=item * Exception handling

Exceptions (C<die>) thrown within C<[% handler %]> callbacks are not
caught by L</run> but passed through to the parent. Please see the
discussion at L</obj> for an example.

=back

[%- END %]
=encoding UTF-8

=head1 NAME

JSON::Create - turn a Perl variable into JSON

=head1 SYNOPSIS

[% INCLUDE "synopsis.pl" | xtidy %]

produces

[% INCLUDE "synopsis-out.txt" | xtidy %]

=head1 DESCRIPTION

This module produces JSON out of Perl. It offers a function
L</create_json> which converts a Perl variable into JSON using common
defaults, and a customizable object created with L</new> where the
user can specify a variety of behaviours. For example, Unicode
escaping into ASCII via L</unicode_escape_all>, floating point number
formatting via L</set_fformat>, escaping of slashes (/) with
L</escape_slash>, JSON serialization of objects with L</obj>, or
boolean handling with L</bool>.

In all cases, errors in processing result in a warning and an
undefined return value. [% see('fatal_errors') %].

This module is a companion to L<JSON::Parse> for parsing JSON into
Perl.

The example programs in this documentation are all found in the
directory F<examples/> in the distribution. All the outputs below are
taken from the actual outputs of the example programs.

=head1 FUNCTIONS

=head2 create_json

    my $json = create_json (\%hash);

Convert a Perl hash reference or array reference into JSON. The return
value is the output JSON.

Details of the conversion of each type are given in
L</CONVERSIONS>.

=head1 CONVERSIONS

This section details what conversions are applied to the various
inputs to produce outputs.

=head2 Hashes

Associative arrays are converted to JSON objects. The keys are written
into JSON as strings, with any control characters escaped. The order
of the keys is as they are supplied by Perl.

[% INCLUDE "hash.pl" | xtidy %]

outputs

[% INCLUDE "hash-out.txt" | xtidy %]

Nested hashes are recursively followed:

[% INCLUDE "nested-hash.pl" | xtidy %]

outputs

[% INCLUDE "nested-hash-out.txt" | xtidy %]

=head2 Arrays

Arrays are converted to JSON arrays. The order of the array is
identical to the Perl one.

[% INCLUDE "array.pl" | xtidy %]

outputs

[% INCLUDE "array-out.txt" | xtidy %]

Nested arrays are recursively followed:

[% INCLUDE "nested-array.pl" | xtidy %]

outputs

[% INCLUDE "nested-array-out.txt" | xtidy %]

Nested hashes and arrays are converted similarly:

[% INCLUDE "nested.pl" | xtidy %]

outputs

[% INCLUDE "nested-out.txt" | xtidy %]

=head2 Scalars

Perl scalars are converted to strings, JSON integers or JSON floats.

=head3 Strings

As far as possible, strings are written as-is to the JSON. JSON
requires Unicode, so all output must be checked for Unicode
validity. Invalid UTF-8 produces the error L</Invalid UTF-8> and the
undefined value is returned. [% see('replace_bad_utf8') %]. Some
whitespace and control characters must be escaped for the output to be
valid JSON. (See L</RFC 7159>.)

For full details of Unicode handling, refer to L</UNICODE HANDLING>.

=head4 Control characters and whitespace

To form valid JSON, bytes of value less than 0x20 in a Perl string
must be converted into JSON escapes, either the whitespace escapes \b
(backspace) \r, \t, \n, and \f, or the form \u0001 for other control
characters. Further, the backslash must be written as C<\\> and double
quotes must be written as C<\">.

[% INCLUDE "weirdstring.pl" | xtidy %]

outputs

[% INCLUDE "weirdstring-out.txt" | xtidy %]

=head4 U+2028 and U+2029 (JavaScript clashes)

    my $out = create_json (["\x{2028}"]);
    # $out = '["\u2028"]'

Although it is not required by the JSON standard, L</create_json>
escapes Unicode code points U+2028 and U+2029 as C<\u2028> and
C<\u2029> for JavaScript compatibility. [%
see('no_javascript_safe')%].

This escaping is necessary for JavaScript because of a clash between
the JSON standard and the JavaScript (ECMAScript) standard. The
characters U+2028 ("LINE SEPARATOR" in the Unicode standard) and
U+2029 ("PARAGRAPH SEPARATOR" in the Unicode standard) are valid
within JSON, as defined by L</RFC 7159>, but invalid within JavaScript
strings, as defined by the ECMA standard (See ECMA Standard ECMA-262,
"ECMAScript Language Specification", 3rd Edition, section 7.3 "Line
Terminators").

=head4 Other escapes

The forward slash, /, known as "solidus" in the JSON specification,
does not have to be escaped, and L</create_json>'s default is not to
escape it. [% see('escape_slash') %].

Other Unicode values are not escaped.  [% see('unicode_escape_all')
%].

=head3 Integers

Integers are printed in the obvious way. Note that what you input to
Perl as an integer, Perl may interpret to be a floating point number,
if it has a very large absolute value, in which case this module will
print it out like a floating point number.

=head3 Floating point numbers

Finite floating point numbers are printed using printf formatting via
C<"%g">, like

    printf ("%g", $number);

[% see('set_fformat') %]

NaN (not a number) values are converted to C<"nan"> (the letters
C<nan> surrounded by double quotes). Positive and negative infinity
are converted to C<"inf"> and C<"-inf"> respectively. [%
see('non_finite_handler') %]. JSON does not allow NaN or infinity as bare
values. From page 6 of L</RFC 7159>:

=over

Numeric values that cannot be represented in the grammar below (such
as Infinity and NaN) are not permitted.

=back

=head3 The undefined value

Undefined values are mapped to the JSON literal "null".

=head3 Booleans

Booleans (C<true> and C<false>) from input via JSON::Parse version
0.37 or later will be turned into the outputs C<true> and
C<false>:

[% INCLUDE "json-parse-bool.pl" | xtidy %]

outputs

[% INCLUDE "json-parse-bool-out.txt" | xtidy %]

Other kinds of objects can be converted to booleans using the method
L</bool> (see below).

=head2 Other types

=head3 Scalar references

Scalar references are dereferenced then treated as scalars. See
L</Scalars>.

=head3 Objects

By default, Perl objects are handled as if non-object types. In other
words, unless you specify object handling, the module breaks
encapsulation. This behaviour can be altered with the method L</obj>
for individual objects, or you can supply your own object handler with
L</obj_handler> which deals with all objects.

=head3 Code, regexes, and other references

A code or other reference (regexes, globs, etc.) in the input prints a
warning and causes the entire return value to be the undefined
value. [% see('type_handler') %].

=head1 METHODS

To alter the format of the output from the defaults of
L</create_json>, create an object with L</new> and then set
preferences on that object before producing output with L</run>.

=head2 new

    my $jc = JSON::Create->new ();

Create a new "JSON::Create" object. You need to use L</run> to
generate JSON with this.

=head2 run

    my $json = $jc->run ($input);

This does exactly the same thing as L</create_json>, unless you have
altered the output format. The return value is the output JSON.

=head2 fatal_errors

    $jc->fatal_errors (1);

If this is called with a true value, errors in the input are upgraded
from warnings to fatal errors.

[% INCLUDE "fatal-errors.pl" | xtidy %]

produces

[% INCLUDE "fatal-errors-out.txt" | xtidy %]

=head2 Methods for formatting the output

These methods work on the object created with L</new> to format the
output JSON in a different way from the default when operating
L</run>. These methods are not applicable to L</create_json>.

=head3 bool

    $jc->bool ('boolean');
    $jc->bool (qw/boolean JSON::Tiny::_Bool/);

The argument is a list of object names. The JSON::Create object,
C<$jc> in the example, will convert objects of these types into the
JSON literals C<true> or C<false> depending on whether Perl thinks
they're true or false. For example,

[% INCLUDE "boolean.pl" | xtidy %]

outputs

[% INCLUDE "boolean-out.txt" | xtidy %]

If you prefer to take over all object handling yourself, there is also
L</obj_handler>, which overrides what is set with C<bool>.

=head4 Interoperability

The boolean values of the following Perl modules can interoperate with
JSON::Create. 

=over

=item L<boolean>

    $jc->bool ('boolean');

=item L<JSON::Tiny>

    $jc->bool ('JSON::Tiny::_Bool');

Round trip compatibility is also confirmed for JSON::Tiny version 0.54.

=item L<JSON::PP>

    $jc->bool ('JSON::PP::Boolean');

Round trip compatibility is also confirmed for JSON::PP version 2.27300.

=item L<Types::Serialiser>

    $jc->bool ('JSON::PP::Boolean');

B<Please note> the above is not a typo, L<JSON::PP::Boolean> is the
correct object type for Types::Serialiser. To confirm this, try

    print ref $Types::Serialiser::false;

=item L<Mojo::JSON>

    $jc->bool ('JSON::PP::Boolean', 'Mojo::JSON::_Bool');

Round trip compatibility is also confirmed for Mojo::JSON version 6.25.

The current version of Mojo::JSON (Mojolicious version 6.25) actually
depends on L<JSON::PP> and uses the type C<JSON::PP::Boolean> for its
true and false values. Older versions used their own type,
C<Mojo::JSON::_Bool>.

JSON::Create's tests for Mojo::JSON compatibility are currently
commented out by default, because different versions of Mojolicious
differ a lot in not only function names but also variable names, as
seen above. If you want to run these tests, please edit the file
F<t/bool.t> in the distribution.

=back

You can also switch on multiple modules using a list:

    $jc->bool (qw/boolean JSON::Tiny::_Bool JSON::PP::Boolean/);

The compatibility of the above modules can be confirmed by running the
test script F<t/bool.t> in the distribution. However, JSON::Create
does not install these modules, so unless you have installed them
yourself, the tests will just be skipped.

More modules will be added to this list as time permits.

=head3 downgrade_utf8

    $jc->downgrade_utf8 (1);

If this is set to a true value, output is never upgraded to character
strings, or C<utf8>. This overrides the default behaviour, which is to
upgrade the output to C<utf8> if any part of the input is C<utf8>, or
if the user has requested replacement with L</replace_bad_utf8> and
there are bad characters in the user's input. See L</UNICODE HANDLING>
for details. Please note that all output of JSON::Create is valid
UTF-8, regardless of what this flag is set to.

This method should be considered experimental.

[% since('0.18') %]

=head3 escape_slash

    $jc->escape_slash (1);

Call this with a true value to make the slash (known as the "solidus"
in the JSON specification) be escaped with a backslash. Call this with
any false value to make the slash not be escaped (the default
behaviour).

[% INCLUDE "escape-slash.pl" | xtidy %]

outputs

[% INCLUDE "escape-slash-out.txt" | xtidy %]

[% since('0.07') %]

=head3 no_javascript_safe

    $jc->no_javascript_safe (1);

If called with a true value, this switches off JavaScript protection
in the output JSON. If called with a false value, the JavaScript
protection is switched on again.

[% INCLUDE "js-safe.pl" | xtidy %]

produces

[% INCLUDE "js-safe-out.txt" | xtidy %]

See also L</U+2028 and U+2029 (JavaScript clashes)>.

=head3 non_finite_handler

   $jc->non_finite_handler (\& handler);

This overrides the default behaviour for handling non-finite floating
point numbers, in other words NaN (not a number) and negative or
positive infinity, with a user-defined routine. The default behaviour
of this module is described at L</Floating point numbers>. 

The routine C<handler> is supplied with the non-finite number as its
sole argument, and returns one argument, the output JSON. For example,
to use always use C<null> in place of the default, supply a function
like the following:

[% INCLUDE "non-finite-handler.pl" | xtidy %]

which produces

[% INCLUDE "non-finite-handler-out.txt" | xtidy %]

[% handler_common('non_finite_handler') %]

[% since(0.17) %]

=head3 obj

    $jc->obj ('Zilog::Z80' => sub { my ($obj) = @_; print "\"Z80\""; });

Register JSON generators for Perl objects. When JSON::Create finds an
object with a registered type, it will call the method you have
supplied.

The argument to C<obj> is a hash. The keys are object names, and the
corresponding values are code references to the JSON serializer for
that object:

    $jc->obj (
        'My::Object' => \& object_to_json,
    );

The output is passed through to the output string unaltered. To have
your JSON output checked for validity, use the L</validate> option.

The function is called with the object reference as its only
argument, as if called like this:

    my $user_json = $my_object->object_to_json ();

The return value of the function, C<object_to_json> in the above
example, must be a single value, a string containing the object's JSON
encoding.

[% INCLUDE "zilog.pl" | xtidy %]

produces

[% INCLUDE "zilog-out.txt" | xtidy %]

The function is called "in scalar context", so

[% INCLUDE "too-many-values.pl" | xtidy %]

produces

[% INCLUDE "too-many-values-out.txt" | xtidy %]

If you need to pass or return more than a single argument, use a
closure:

[% INCLUDE "closure.pl" | xtidy %]

produces

[% INCLUDE "closure-out.txt" | xtidy %]

Exceptions (fatal errors) are not caught by JSON::Create, so if you
want to halt the execution of JSON::Create, you can throw an exception
within your callback.

[% INCLUDE "exception.pl" | xtidy %]

produces

[% INCLUDE "exception-out.txt" | xtidy %]

If you prefer to take over all object handling yourself, there is also
L</obj_handler>.

[% handler_undef %]

=head3 obj_handler

    $jc->obj_handler (\& my_obj_handler);

Supply an object handler. If you supply this, all objects will be
handled by your handler. For example, you can replace all objects with
'null' or die if an object is found.

[% handler_common('obj_handler') %]

Here is an example of handling various types of object with your own
handler:

[% INCLUDE "obj-handler.pl" | xtidy %]

This produces

[% INCLUDE "obj-handler-out.txt" | xtidy %]

Here is an example of a "try harder" routine which does something like
the L<JSON> module does, by looking for methods on all objects:

[% INCLUDE "try-harder.pl" | xtidy %]

This outputs

[% INCLUDE "try-harder-out.txt" | xtidy %]

This C<obj_handler> overrides whatever you have set with L</bool> or
L</obj>. Currently, it does not print a warning about this. See
L</BUGS>. The routine you use to handle objects may be the same as the
routine you use to handle types. See L</type_handler>. For more
details about the callbacks, see L</obj>.

[% since('0.13') %]

=head3 replace_bad_utf8

    $jc->replace_bad_utf8 (1);

Replace invalid UTF-8 in the inputs with the Unicode replacement
character U+FFFD, rather than produce the warning or error L</Invalid
UTF-8>. 

If C<replace_bad_utf8> is used on input containing only strings not
marked as character strings, and bad UTF-8 is found, JSON::Create
marks the output as a character string. This is counterintuitive but
unfortunately necessary, because otherwise the replacement character
itself is just a series of broken bytes. [% see('downgrade_utf8') %].

[% since(0.12) %]

=head3 set_fformat

    $jc->set_fformat ('%e');

This sets the printf-style format string used to print floating point
numbers. This is validated and a warning printed if the format cannot
be used. The format is also restricted to a maximum length to prevent
buffer overflows within the module.

[% INCLUDE "set-fformat.pl" | xtidy %]

outputs

[% INCLUDE "set-fformat-out.txt" | xtidy %]

[% since('0.07') %]

=head3 type_handler

    $jc->type_handler (sub {return 'null'});

By default, when JSON::Create encounters a variable of a type which it
doesn't know what to do with, such as a glob or code reference, it
prints a warning and returns an undefined value. See L</Code, regexes,
and other references>.  The method C<type_handler> sets up a callback
which is called when a variable of an unhandled type is found in the
input. For example, if you want to put the JSON literal C<null> in the
output when you find an unhandled type rather than print an error, the
above example will do it.

[% handler_common('type_handler') %]

The following example showing a few possibilities for handling types:

[% INCLUDE "type-handler.pl" | xtidy %]

This outputs

[% INCLUDE "type-handler-out.txt" | xtidy %]

The type handler function you supply will be called with one value,
the reference it is supposed to handle, and should return one value, a
valid JSON string.  If you want to have your return value validated,
use the L</validate> option (see below).

[% since('0.10') %]

=head3 unicode_escape_all

    $jc->unicode_escape_all (1);

Call this with a true value to make all Unicode characters be escaped
into the C<\u3000> format. A false value switches that off again.

For example,

[% INCLUDE "escape-all.pl" | xtidy %]

outputs

[% INCLUDE "escape-all-out.txt" | xtidy %]

Note that JSON::Create contains its own UTF-8 validation, and this
escaping is applied regardless of whether Perl marks the bytes as
"utf8" or not:

[% INCLUDE "escape-all-no-utf8.pl" | xtidy %]

outputs

[% INCLUDE "escape-all-no-utf8-out.txt" | xtidy %]

=head3 unicode_upper

    $jc->unicode_upper (1);

Call this with a true value to make Unicode escapes use upper case
letters in the hexadecimal. See the example under
L</unicode_escape_all>.

=head3 validate

    $jc->validate (1);

If this is called with a true value, JSON::Create validates the
user-generated JSON given by the callbacks registered with L</obj> and
L</type_handler>. The validation is done via the routine
C<assert_valid_json> of L<JSON::Parse>, so that module must be
installed, otherwise the call to C<validate> will fail.

If JSON::Parse is installed, and the JSON fails to validate, this will
produce a warning containing the string and the error produced by
C<assert_valid_json>, and the return value will be undefined.

[% since('0.07') %]

=head1 EXPORTS

The module exports nothing except by request. One function,
L</create_json>, is exported on request.

=head1 INSTALLATION

The module uses C internally, so you need a C compiler to install
it. If the compiled library cannot be loaded, there is also a backup
"pure Perl" module JSON::Create::PP in the distribution.

=head1 UNICODE HANDLING

This section details JSON::Create's handling of Unicode within
strings. This involves the distinction between two things with
confusingly similar names, Perl character strings, C<utf8>, and the
Unicode encoding C<UTF-8>.

=over

=item UTF-8 only

JSON::Create only consumes and produces the UTF-8 encoding of
Unicode. If you need a different encoding, please use the L<Encode>
module to encode the output.

=item Input strings must be UTF-8

All strings within the input must be UTF-8 encoded. This does not mean
that the strings must be Perl character strings (Perl's C<utf8>), it
means that input strings must be valid UTF-8. Input strings can be
either Perl character strings or bytes, but if they are bytes, the
bytes must be valid UTF-8.

To illustrate this, examine the following example:

[% INCLUDE "valid-chars.pl" | xtidy %]

This produces the following output:

[% INCLUDE "valid-chars-out.txt" | xtidy %]

The point here is that the UTF-8 validation is carried out regardless
of whether Perl thinks that the input string is "utf8". The string in
the third call to L</create_json> is not marked as utf8 by Perl but
still fails as invalid UTF-8.

This restriction is imposed by the JSON standard, which says that
strings must be in Unicode:

=over

A string is a sequence of zero or more Unicode characters [UNICODE].

=back

See L</RFC 7159>, section "1 Introduction", on page 2.

=item All of JSON::Create's output is valid UTF-8

All of the output of either the function L</create_json> or the method
L</run> is valid UTF-8. This does not mean that output strings are
marked as Perl character strings (C<utf8>), it means that the output
has been validated as UTF-8.

=item A single utf8 in the input makes the entire output utf8

If a single string anywhere in the input is a Perl character string,
in other words marked as C<utf8>, the entire output string is marked
as a Perl character string, C<utf8>. Since the output is always valid
UTF-8, this should not cause a problem in practice. [%
see('downgrade_utf8') %].

=item Using replace_bad_utf8 may cause a utf8 upgrade

Please see the discussion under L</replace_bad_utf8>.

=back

=head1 DIAGNOSTICS

All diagnostics are warnings by default. [% see('fatal_errors') %].

=over

=item Invalid UTF-8

(Warning) Bytes in a Perl string were not valid UTF-8. [% see('replace_bad_utf8') %].

=item JSON::Parse::assert_valid_json failed

(Warning) The user requested validation with L</validate> and this failed.

=item Input's type cannot be serialized to JSON

(Warning) A reference type such as a code reference, regexp, or glob
was found in the user's input. See L</type_handler>.

=back

=head1 PERFORMANCE

This module is fairly new on the scene, so speed is not a key issue
until the module is demonstrably producing correct outputs.

However, due to user interest, there is a benchmarking script in
F<bench/bench.pl> which compares the performance of the module with
L<JSON::XS> and L<Cpanel::JSON::XS>. Outputs look like this:

[% INCLUDE "/home/ben/projects/json-create/bench/bench.output" | indent (4) %]

This only compares a few simple cases in which the output is
demonstrably correct. Also, at least on my computer, the numbers seem
to vary wildly from one test to another. The benchmarking script also
contains commented out code to test against L<JSON::DWIW> if you are
interested.

Please note that the numbers for the floating point results are at the
moment unfairly skewed in favour of JSON::Create, because whereas
JSON::XS prints out the full available precision of the number (which
is about equivalent to printing with a format C<%.15g>), JSON::Create
prints only six digits of precision, creating a false impression of
greater speed. Work on this is currently in progress.

=head1 BUGS

There is currently no facility to add whitespace to the output JSON.

There is currently no way to delete object handlers set via L</obj>
from a JSON::Create object.

There are a few remaining undecided issues around the default object
serialization.

No warning is printed when the user uses clashing methods like
L</bool> and L</obj_handler>.

Features added since version 0.16 of the module are not yet
implemented in JSON::Create::PP.

There is a bug in JSON::Create::PP's handling of non-integer numbers.

The floating point printing loses precision on round trips.

=head1 HISTORY

L</set_fformat> was added in version 0.07.

L</validate> was added in version 0.07.

L</replace_bad_utf8> was added in version 0.12.

L</obj_handler> was added in version 0.13. This version also added
loading of the Pure-Perl version of the module, JSON::Create::PP, if
the loading of JSON::Create failed.

L</non_finite_handler> was added in version 0.17.

L</downgrade_utf8> was added in version 0.18.

=head1 SEE ALSO

=over

=item RFC 7159

JSON is specified in L<RFC 7159 "The application/json Media Type for
JavaScript Object Notation
(JSON)"|http://www.ietf.org/rfc/rfc7159.txt>.

=item json.org

L<http://json.org> is the website for JSON, authored by Douglas
Crockford.

=item JSON::Parse

This module is a companion module to the same author's
L<JSON::Parse>. Please see that module's documentation for links to
the JSON standard itself, a summary of the ever-growing list of JSON
modules on CPAN (under "SEE ALSO") and the reasons why I decided to
write these two modules (under "HISTORY").

=item L<JSON::Create::PP>

This is a backup module for JSON::Create in pure Perl.

=back

[% INCLUDE "author" %]

=cut

